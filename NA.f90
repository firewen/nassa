    subroutine NA(rx,ry,rz,nst,vmodel,p,nt,ns,nr,niter,nd,lb,hb,dt,vm,vf)
    use raytracing
    use omp_lib
    implicit none
    
    integer :: nst,nt,ns,nr,niter,nd
    real*8 :: rx(nst),ry(nst),rz(nst),lb(nd),hb(nd),p(nst,nt)
    real*8 :: dt
    type(Velocity) :: vmodel
    
    real*8 :: vf(ns+ns*niter,nd),vm(ns+ns*niter)
    
    integer :: np
    real*8 :: v(ns,nd),v0(ns,nd),vm0(ns),vm1(ns+ns*niter),trand(nd),xa(nd),d0(ns),x(ns)
    integer :: idx(ns+ns*niter)
    integer :: i,j,loop,ir,loopp,icorr
    real*8 :: xl,xh
    real*8 :: factor
    
    real*8 :: fitness
    
    real*8 :: t1,t2
    
    np = int(ns/nr)
    
    vf = 0.0; vm0 = 0.0
    
    v = 0.0
    vm = 0.0
    
    call random_seed()
   
    print *, 'procs',omp_get_num_procs()
    print *, 'threads',omp_get_num_threads() 
    !call cpu_time(t1)
    t1 = omp_get_wtime()
    !$omp parallel default(shared) private(i,trand)
    !$omp do
    do i=1,ns
        call random_number(trand)
        v(i,:) = trand*(hb-lb)+lb
        vm(i) = fitness(v(i,:),rx,ry,rz,nst,nt,dt,p,vmodel)
        
        !write(*,'(4(f9.4,1x),1x,i)') v(i,:),vm(i),OMP_get_num_threads()
    end do
    !$omp end do nowait
    !$omp end parallel
    !call cpu_time(t2)
    t2 = omp_get_wtime()
    print *,"time :",t2-t1
    
    vf(1:ns,:) = v
    
    factor = 1.0/110.0
    lb(3) = lb(3)*factor
    hb(3) = hb(3)*factor
    
    do loop=1,niter
        
        !print *, 'loop: ',loop
        
        vm1 = vm
        call sort(vm1(1:ns+(loop-1)*ns),idx(1:ns+(loop-1)*ns),ns+(loop-1)*ns)    ! sort the misfit obtained in the previous iteration
        
        v = vf(idx(1:ns),:)     ! choose the first ns vitual source 
                                ! to generate the new group of Voronoi cell
        
        ! choose nr vitual sources which the misfit is the lowest
        ! and then start from these nr vitual sources and randomly walk in 
        ! the relative Voronoi cell to generate a new group of vitual sources
        v0 = v
        v0(:,3) = v0(:,3)*factor
        do ir=1,nr
            xa = v0(ir,:)
            
            ! xb should be generated by the uniform random walk from xa through each components
            do loopp=1,np
                do icorr=1,nd
                    
                    do i=1,ns
                        d0(i) = sum((v0(i,:)-xa)**2)-(v0(i,icorr)-xa(icorr))**2
                    end do
                    
            ! determine the boundary of icorr-th coordinate of Voronoi cell at point xa
            ! Sambridge, 1999, eq. 19 
                    do i=1,ns
                        if (i == ir) then
                            x(i) = xa(icorr)
                        else
                            x(i) = (v0(ir,icorr)+v0(i,icorr)+(d0(ir)-d0(i))/(v0(ir,icorr)-v0(i,icorr)))/2.0
                        end if
                    end do
                    
             ! Sambridge, 1999, eq. 20,21
                    xl = minval(x)
                    xh = maxval(x)
                    do i=1,ns
                        if (x(i) < xa(icorr)) then
                            if (x(i) > xl) then
                                xl = x(i)
                            end if
                        end if
                        
                        if (x(i) > xa(icorr)) then
                            if (x(i) < xh) then
                                xh = x(i)
                            end if
                        end if
                    end do
                    if (xl < lb(icorr)) xl = lb(icorr)
                    if (xh > hb(icorr)) xh = hb(icorr)
                    
                    !call random_seed()
                    call random_number(trand(1))
                    xa(icorr) = xl+trand(1)*(xh-xl)
                end do
                
                v((ir-1)*np+loopp,:) = xa
            end do
        end do
        
        v(:,3) = v(:,3)/factor
        !print *,shape(v),ns+(loop-1)*ns+1
        vf(ns+(loop-1)*ns+1:ns+loop*ns,:) = v
        
        vm0 = 0.0
        t1 = omp_get_wtime()
        !$omp parallel default(shared) private(i)
        !$omp do
        do i=1,ns
            vm0(i) = fitness(v(i,:),rx,ry,rz,nst,nt,dt,p,vmodel)
        end do
        !$omp end do nowait
        !$omp end parallel
        t2 = omp_get_wtime()
!        print *, 'loop: ',loop," time :",t2-t1
        vm(ns+(loop-1)*ns+1:ns+(loop-1)*ns+ns) = vm0
        
    end do
    
    
    return
    end subroutine NA
    
    subroutine sort(a,idx,n)
    implicit none
    integer :: n
    real*8 :: a(n)
    integer :: idx(n)
    
    integer :: i
    
    do i=1,n
        idx(i) = i
    end do
    
    call quick_sort(a,idx,n,1,n)
     
    return
    end subroutine sort
    
    recursive subroutine quick_sort(a,idx,n,s,e)
    implicit none
    integer :: n ! 表示类型的大小
    real*8 :: a(n) ! 存放数据的类型
    integer :: idx(n)
    integer :: s ! 传入的参数, 这一组的类型起始位置
    integer :: e ! 传入的参数, 这一组的类型结束位置
    
    integer :: l,r ! 用来找a(l)>k及a(r)<k时用的
    real*8 :: k ! 记录键值a(s)
    real*8 :: temp ! 交换两个数值时用的
    integer :: itmp
    
    ! 首先要先给定l,r的初值. l要从头开始,e则要从尾开始
    l=s
    r=e+1
    
    !print *,l,r
    ! right值 > left值 时才有必要进行排序
    if ( r<=l ) return

    k=a(s) ! 设定键值
    do while(.true.)
    ! 找出a(l)<k的所在
        do while( .true. )
            l=l+1
            if (l >= e) exit
            if (a(l) > k) exit
            !if ( (l>=e) .or. (a(l) > k) ) exit
        end do
    ! 找出a(r)>k的所在
        do while( .true. )
            r=r-1
            if (r <= s) exit
            if (a(r) < k) exit
            !if ( (r<=s) .or. (a(r) < k) ) exit
        end do
    ! 如果right 跑到 left的左边时, 循环就该结束了
        if ( r <= l ) exit
    ! 交换a(l),a(r)的数值
        temp=a(l)
        a(l)=a(r)
        a(r)=temp
        itmp = idx(l)
        idx(l) = idx(r)
        idx(r) = itmp
    end do
    ! 交换a(s),a(r)的数值
    temp=a(s)
    a(s)=a(r)
    a(r)=temp
    itmp = idx(s)
    idx(s) = idx(r)
    idx(r) = itmp
    ! 把r之前的数据重新分组,再做排序
    call quick_sort(a,idx,n,s,r-1)
    ! 把r之后的数据重新分组,再做排序
    call quick_sort(a,idx,n,r+1,e)
    return
    end subroutine quick_sort
